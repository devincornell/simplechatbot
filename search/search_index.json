{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the <code>simplechatbot</code> Python package! This package provides tools for working with LLM agents - in particular, chatbots that track tools and conversation history.</p> <p>See the examples in the navbar to the left!</p>"},{"location":"#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Adding clone methods.</li> <li>Update repr on <code>StreamResult</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+ssh://git@github.com/devincornell/simplechatbot.git@main\n</code></pre> <p>When inside the package directory: Basic install: </p> <p><code>pip install .</code></p> <p>This package uses buildtools - see <code>pyproject.toml</code> for package details.</p>"},{"location":"#makefile","title":"Makefile","text":"<p>You can also use <code>make</code>.</p> <p>To install: </p> <pre><code>make install\nmake uninstall\n</code></pre>"},{"location":"#importing","title":"Importing","text":"<p>Basic importing works as you would expect.</p> <p><code>import simplechatbot</code></p>"},{"location":"#generating-documentation","title":"Generating Documentation","text":"<p>The Makefile has most of these commands, but including them here jsut in case.</p> <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre> <p>Start Test Server</p> <pre><code>mkdocs serve\n</code></pre> <p>Build the documentation.</p> <pre><code>mkdocs build\n</code></pre> <p>Publish the documation</p> <pre><code>mkdocs gh-deploy --force\n</code></pre>"},{"location":"#example-documentation","title":"Example Documentation","text":"<p>In the Makefile I included the commands that will take example jupyter notebooks and convert them to markdown so that <code>mkdocs</code> can eventually convert them to html for the website. Simply add a notebook to the <code>site_examples</code> folder and it will be automatically converted to markdown and placed in the right folder.</p> <pre><code>EXAMPLE_NOTEBOOK_FOLDER = ./site_examples/# this is where example notebooks are stored\nEXAMPLE_NOTEBOOK_MARKDOWN_FOLDER = ./docs/examples/# this is where example notebooks are stored\n\nexample_notebooks:\n    -mkdir $(EXAMPLE_NOTEBOOK_MARKDOWN_FOLDER)\n    jupyter nbconvert --to markdown $(EXAMPLE_NOTEBOOK_FOLDER)/*.ipynb\n    mv $(EXAMPLE_NOTEBOOK_FOLDER)/*.md $(EXAMPLE_NOTEBOOK_MARKDOWN_FOLDER)\n</code></pre>"},{"location":"examples/a-overview/","title":"Introduction","text":"<p>This is a brief introduction to the <code>simplechatbot</code> package.</p> <pre><code>import sys\nsys.path.append('..')\n\nimport simplechatbot\n</code></pre>"},{"location":"examples/a-overview/#instantiating-chatbot-objects","title":"Instantiating <code>ChatBot</code> Objects","text":"<p><code>ChatBot</code> instances maintain three elements: a chat model (or runnable) LLM, chat history, and available tools / functions.</p> <p>It may be instantiated from any langchain chat model or runnable.</p> <pre><code>from langchain_openai import ChatOpenAI\n\n# optional: use this to grab keys from a json file rather than setting system variables\nkeychain = simplechatbot.APIKeyChain.from_json_file('../keys.json')\n\nopenai_model = ChatOpenAI(model='gpt-4o-mini', api_key=keychain['openai'])\nchatbot = simplechatbot.ChatBot.from_model(model=openai_model)\nprint(chatbot)\n</code></pre> <pre><code>ChatBot(model_type=ChatOpenAI, model_name=\"gpt-4o-mini\", tools=None)\n</code></pre> <p>The <code>tools</code> parameter allows you to pass any langchain tools you want your chatbot to be able to use. You can use one of Langchain's built-in tools (such as <code>FileManagementToolkit</code>) or define your own custom tools. I will use <code>FileManagementToolkit</code> for demonstration purposes here.</p> <pre><code>import langchain_core.tools\n\n@langchain_core.tools.tool\ndef check_new_messages(text: str, username: str) -&gt; str:\n    '''Check messages.'''\n    return f'No new messages.'\n\nchatbot = simplechatbot.ChatBot.from_model(\n    model = openai_model,\n    tools = [check_new_messages],\n)\n</code></pre> <p>You can see that tools are added to an internal <code>ToolSet</code> object.</p> <pre><code>chatbot.toolset\n</code></pre> <pre><code>ToolSet(tools={'check_new_messages': StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)})\n</code></pre> <p>Set a system prompt for the chatbot by passing it as the <code>system_prompt</code> argument.</p> <pre><code>system_prompt = '''\nYou are a creative designer who has been tasked with creating a new slogan for a company.\nThe user will describe the company, and you will need to generate three slogan ideas for them.\n'''\nchatbot = simplechatbot.ChatBot.from_model(\n    model = openai_model,\n    tools = [check_new_messages],\n    system_prompt=system_prompt,\n)\n</code></pre> <p>While the LLM itself is just a function, we build conversation-like behavior by storing a chat history. In <code>simplechatbot</code>, the history is stored in a <code>ChatHistory</code>, which is just a list subtype where list elements contain langchain <code>BaseMessage</code> subtypes. You can access it through the <code>history</code> property, and work with it just as a list.</p> <p>Here you can see that the system prompt is simply added as the first message in the chatbot history. </p> <pre><code>chatbot.history\n</code></pre> <pre><code>[SystemMessage(content='\\nYou are a creative designer who has been tasked with creating a new slogan for a company.\\nThe user will describe the company, and you will need to generate three slogan ideas for them.\\n', additional_kwargs={}, response_metadata={})]\n</code></pre> <p>To see the conversation history that is sent to the LLM, you can use the <code>get_buffer_string</code> method. This uses the same langchain methods used to invoke the LLM, so it is useful for debugging.</p> <pre><code>print(chatbot.history.get_buffer_string())\n</code></pre> <pre><code>System: \nYou are a creative designer who has been tasked with creating a new slogan for a company.\nThe user will describe the company, and you will need to generate three slogan ideas for them.\n</code></pre> <p>Note that history is a <code>list</code> subtype, so you can iterate through messages as you would expect.</p> <pre><code>for m in chatbot.history:\n    print(m)\n</code></pre> <pre><code>content='\\nYou are a creative designer who has been tasked with creating a new slogan for a company.\\nThe user will describe the company, and you will need to generate three slogan ideas for them.\\n' additional_kwargs={} response_metadata={}\n</code></pre>"},{"location":"examples/a-overview/#high-level-chat-and-chat_stream-methods","title":"High-level <code>chat</code> and <code>chat_stream</code> Methods","text":"<p>There are two primary methods used to interact with the chatbot: <code>chat</code> and <code>chat_stream</code>. </p> <p>These are the method use-cases:</p> <p><code>.chat()</code> \u2192 <code>ChatResult</code>: Use when you want to retrieve the full LLM response at once when it finishes.</p> <p><code>.chat_stream()</code> \u2192 <code>ChatStream</code>: Use when you would like to show intermediary results to the user as they are received from the LLM.</p> <pre><code>chatbot.chat('My name is Devin.')\n</code></pre> <pre><code>ChatResult(content=Hi Devin! How can I assist you today? Are you looking to create a slogan for a specific company or project?, tool_calls=[])\n</code></pre> <pre><code>chatbot.chat_stream('My name is Devin and I am a creative designer.')\n</code></pre> <pre><code>ChatStream(message_iter=&lt;generator object RunnableBindingBase.stream at 0x106f2d300&gt;, chatbot=ChatBot(model_type=ChatOpenAI, model_name=\"gpt-4o-mini\", tools=['check_new_messages']), toolset=ToolSet(tools={'check_new_messages': StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)}), add_reply_to_history=True, full_message=AIMessageChunk(content='', additional_kwargs={}, response_metadata={}), exhausted=False)\n</code></pre> <p>Again use the <code>get_buffer_string</code> method to conveniently view the chat history.</p> <pre><code>print(chatbot.history.get_buffer_string())\n</code></pre> <pre><code>System: \nYou are a creative designer who has been tasked with creating a new slogan for a company.\nThe user will describe the company, and you will need to generate three slogan ideas for them.\n\nHuman: My name is Devin.\nAI: Hi Devin! How can I assist you today? Are you looking to create a slogan for a specific company or project?\nHuman: My name is Devin and I am a creative designer.\n</code></pre> <p>From the response to the prompt below you can see that it is maintained in the chat history because it \"retains\" knowledge that is given to it.</p> <pre><code>chatbot.chat('I have a quiz for you: what is my name?')\n</code></pre> <pre><code>ChatResult(content=Your name is Devin!, tool_calls=[])\n</code></pre>"},{"location":"examples/a-overview/#chat-and-chatresult-objects","title":"<code>.chat()</code> and <code>ChatResult</code> Objects","text":"<p>The <code>chat</code> method submits the current message and all history to the LLM and returns the reply as a <code>ChatResult</code> object.</p> <pre><code>chatbot.chat('Hello world.')\n</code></pre> <pre><code>ChatResult(content=Hello, Devin! How can I assist you today?, tool_calls=[])\n</code></pre> <p>If you want to submit the current chat history but do not want to add a new message, you can pass <code>None</code> as the message argument.</p> <pre><code>chatbot.chat(None)\n</code></pre> <pre><code>ChatResult(content=If there's anything specific you'd like to discuss or if you need help with a project, feel free to let me know!, tool_calls=[])\n</code></pre> <p>Alternatively, if you want to submit a query to the LLM but do not want to save it in the history, set <code>add_to_history = False</code>.</p> <pre><code>chatbot.chat('Hello world.', add_to_history=False)\n</code></pre> <pre><code>ChatResult(content=Hello again, Devin! How can I help you today?, tool_calls=[])\n</code></pre> <p><code>ChatResult</code> objects are returned from <code>chat()</code> and <code>invoke()</code> calls and include the LLM response text or tool calling information.</p> <pre><code>result = chatbot.chat('What is my name?')\nresult\n</code></pre> <pre><code>ChatResult(content=Your name is Devin!, tool_calls=[])\n</code></pre> <p>If no tool calls were requested from the LLM, you can access the response as a string through the <code>content</code> property.</p> <pre><code>result.content\n</code></pre> <pre><code>'Your name is Devin!'\n</code></pre> <p>If tool calls were made, the content will be empty but you can get information about any tool calls through the <code>tool_calls</code> attribute. Notice that no tool calls were requested by the LLM in the response to this query.</p> <pre><code>result.tool_calls\n</code></pre> <pre><code>[]\n</code></pre> <p>If there were tool calls, you can execute them using the <code>execute_tools</code> method.</p> <pre><code>result.execute_tools()\n</code></pre> <pre><code>{}\n</code></pre> <p>We provided the chatbot with a tool called <code>check_new_messages</code> earlier, and the LLM will request a tool call if the user requests it.</p> <pre><code>result = chatbot.chat('Check new messages.')\nresult.tool_calls\n</code></pre> <pre><code>[ToolCallInfo(id='call_zLXf8TVFZd3azJ88wuPZfB3S', name='check_new_messages', type='tool_call', args={'text': 'Check new messages.', 'username': 'devin'}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;))]\n</code></pre> <p>The <code>execute_tools</code> method returns a dictionary of <code>ToolCallResult</code> objects which contain the tool call information from the LLM (<code>ToolCallInfo</code>) and the return value of the tool execution.</p> <pre><code>tool_results = result.execute_tools()\ntool_results\n</code></pre> <pre><code>{'check_new_messages': ToolCallResult(info=ToolCallInfo(id='call_zLXf8TVFZd3azJ88wuPZfB3S', name='check_new_messages', type='tool_call', args={'text': 'Check new messages.', 'username': 'devin'}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)), return_value='No new messages.')}\n</code></pre> <p>Use the <code>return_value</code> attribute to access these results.</p> <pre><code>tool_results['check_new_messages'].return_value\n</code></pre> <pre><code>'No new messages.'\n</code></pre>"},{"location":"examples/a-overview/#chat_stream-and-streamresult-objects","title":"<code>.chat_stream()</code> and <code>StreamResult</code> Objects","text":"<p><code>chat_stream</code> is very similar to <code>chat</code>, but allows you to return content to the user as soon as the LLM produces it. The method returns a <code>StreamResult</code> object which has an iterator interface that accumulates results from the LLM while also returning incremental results.</p> <p>In this example, I call <code>chat_stream</code> to retrieve a <code>StreamResult</code> object, which I then iterate through to retrieve and print all results.</p> <pre><code>stream = chatbot.chat_stream('What is my name?')\nfor r in stream:\n    print(r.content, end='', flush=True)\nstream\n</code></pre> <pre><code>Your name is Devin!\n\n\n\n\nChatStream(message_iter=&lt;generator object RunnableBindingBase.stream at 0x12ce61b70&gt;, chatbot=ChatBot(model_type=ChatOpenAI, model_name=\"gpt-4o-mini\", tools=['check_new_messages']), toolset=ToolSet(tools={'check_new_messages': StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)}), add_reply_to_history=True, full_message=AIMessageChunk(content='Your name is Devin!', additional_kwargs={}, response_metadata={'finish_reason': 'stop', 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_d02d531b47'}), exhausted=True)\n</code></pre> <p>You can check the <code>exhausted</code> flag to see if the LLM has returned all results yet.</p> <pre><code>stream = chatbot.chat_stream('What is my name?')\nprint(stream.exhausted)\nfor r in stream:\n    print(r.content, end='', flush=True)\nprint(stream.exhausted)\nstream\n</code></pre> <pre><code>False\nYour name is Devin!True\n\n\n\n\n\nChatStream(message_iter=&lt;generator object RunnableBindingBase.stream at 0x12ce61f30&gt;, chatbot=ChatBot(model_type=ChatOpenAI, model_name=\"gpt-4o-mini\", tools=['check_new_messages']), toolset=ToolSet(tools={'check_new_messages': StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)}), add_reply_to_history=True, full_message=AIMessageChunk(content='Your name is Devin!', additional_kwargs={}, response_metadata={'finish_reason': 'stop', 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_d02d531b47'}), exhausted=True)\n</code></pre> <p>After retrieving all of the LLM response, you can check if any tool calls are required.</p> <pre><code>stream = chatbot.chat_stream('Check my messages.')\nfor r in stream:\n    print(r.content, end='', flush=True)\nstream.tool_calls\n</code></pre> <pre><code>[ToolCallInfo(id='call_RONeUxpHmfeVKHg8AHJm1LyX', name='check_new_messages', type='tool_call', args={'text': 'Check my messages.', 'username': 'devin'}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;))]\n</code></pre> <p>And you would similarly execute tools by calling <code>execute_tools</code>. Note that you cannot call this method if the stream has not been exhausted.</p> <pre><code>stream.execute_tools()\n</code></pre> <pre><code>{'check_new_messages': ToolCallResult(info=ToolCallInfo(id='call_RONeUxpHmfeVKHg8AHJm1LyX', name='check_new_messages', type='tool_call', args={'text': 'Check my messages.', 'username': 'devin'}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12d08f600&gt;)), return_value='No new messages.')}\n</code></pre> <p>You can use the <code>result</code> method to get a <code>ChatResult</code> object instead. If it has not retrieved all results from the LLM, it will do so before returning.</p> <pre><code>chatbot.chat_stream('Hello world.').result()\n</code></pre> <pre><code>ChatResult(content=Hello again, Devin! How can I assist you today?, tool_calls=[])\n</code></pre>"},{"location":"examples/a-overview/#low-level-llm-methods-invoke-and-stream","title":"Low-level LLM Methods: <code>invoke</code> and <code>stream</code>","text":"<p>These lower-level <code>invoke</code> and <code>stream</code> methods are used by the <code>chat</code> and <code>chat_stream</code> methods to submit prompts to the LLM. They can allow you to interact with the LLM and tools/functions without chat history. Their signatures are very similar to high-level methods and they return the same types.</p> <p>NOTE: These methods ignore the system prompt!</p> <p>The low-level <code>invoke</code> method returns a <code>ChatResult</code> object with the content and tool call information.</p> <pre><code>result = chatbot.invoke('Hello world!')\nresult\n</code></pre> <pre><code>ChatResult(content=Hello! How can I assist you today?, tool_calls=[])\n</code></pre> <p>And <code>stream</code> is very similar to <code>chat_stream</code> except that it ignores chat history.</p> <pre><code>stream = chatbot.stream('Check messages.')\nfor r in stream:\n    print(r.content, end='', flush=True)\nstream.execute_tools()\n</code></pre> <pre><code>Please provide the text of the message and the username you want to check.\n\n\n\n\n{}\n</code></pre>"},{"location":"examples/a-overview/#chat-user-interface","title":"Chat User Interface","text":"<p>Of course, what is a chatbot if you can't actually use it? To run an interactive command-line chat, use <code>.ui.start_interactive</code>.</p> <pre><code># uncomment to start interactive chat\n#chatbot.ui.start_interactive(stream=True, show_intro=True, show_tools=True)\n</code></pre>"},{"location":"examples/b-tool_calling/","title":"Tool Calling","text":"<p><code>simplechatbot</code> empowers chatbot agents with the ability to produce arguments for arbitrary user functions instead of providing a text response to the user's prompt. Using this interface you can enable features such as web searching, email sending/checking, file browsing, image creation, or any other functionality that can be accessed through Python. The LLM will \"decide\" whether and which tools/functions should be executed based on a given prompt, so the key is to use tools with clear and concise instructions.</p> <p>Under the hood, <code>ChatBot</code> instances maintain a collection of langchain tools which can be extracted from toolkits or even factory methods that accept the chatbot itself as a parameter. Tools may also be added at the time of LLM execution to enable dynamic systems of available tools.</p> <p>You can create your own custom tools or choose from Langchain's built-in tools. I will use <code>FileManagementToolkit</code> for demonstration purposes here.</p> <pre><code>import sys\nsys.path.append('..')\n\nimport simplechatbot\nfrom simplechatbot.openai import OpenAIChatBot\n</code></pre>"},{"location":"examples/b-tool_calling/#enabling-tools","title":"Enabling Tools","text":"<p>Start by creating a new example tool that can enables the LLM to check email for the user. We create this tool using the <code>@langchain_core.tools.tool</code> decorator.</p> <pre><code>import langchain_core.tools\n\n@langchain_core.tools.tool\ndef check_new_messages() -&gt; str:\n    '''Check messages.'''\n    return f'No new messages.'\n</code></pre> <p>We include this tool as part of the chatbot by passing the function through the <code>tools</code> argument.</p> <pre><code>keychain = simplechatbot.APIKeyChain.from_json_file('../keys.json')\n\nsystem_prompt = '''\nYou are designed to answer any question the user has and send/check messages if needed.\nWhen the user requests you to check your messages, you should display the retrieved messages\n to the user.\n'''\n\nchatbot = OpenAIChatBot.new(\n    model_name = 'gpt-4o-mini', \n    api_key=keychain['openai'],\n    system_prompt=system_prompt,\n    tools = [check_new_messages],\n)\n</code></pre> <p>Now the LLM will have access to these tools. While the chatbot instance stores the LLM object in the <code>_model</code> attribute, you can use <code>model</code> to get the LLM with bound tools.</p> <pre><code>chatbot.model\n</code></pre> <pre><code>RunnableBinding(bound=ChatOpenAI(client=&lt;openai.resources.chat.completions.Completions object at 0x106927860&gt;, async_client=&lt;openai.resources.chat.completions.AsyncCompletions object at 0x12c19f7d0&gt;, root_client=&lt;openai.OpenAI object at 0x12bcd5a60&gt;, root_async_client=&lt;openai.AsyncOpenAI object at 0x12c19da90&gt;, model_name='gpt-4o-mini', model_kwargs={}, openai_api_key=SecretStr('**********')), kwargs={'tools': [{'type': 'function', 'function': {'name': 'check_new_messages', 'description': 'Check messages.', 'parameters': {'properties': {}, 'type': 'object'}}}]}, config={}, config_factories=[])\n</code></pre> <p>You can also use the method <code>get_model_with_tools</code> to get the tool-bound model with any additional tools. The <code>invoke</code>, <code>stream</code>, <code>chat</code>, and <code>chat_stream</code> methods all use this under-the hood so you can add any tools, toolkits, or tool factories to the model at invokation.</p> <pre><code>chatbot.get_model_with_tools(tools=None)\n</code></pre> <pre><code>(RunnableBinding(bound=ChatOpenAI(client=&lt;openai.resources.chat.completions.Completions object at 0x106927860&gt;, async_client=&lt;openai.resources.chat.completions.AsyncCompletions object at 0x12c19f7d0&gt;, root_client=&lt;openai.OpenAI object at 0x12bcd5a60&gt;, root_async_client=&lt;openai.AsyncOpenAI object at 0x12c19da90&gt;, model_name='gpt-4o-mini', model_kwargs={}, openai_api_key=SecretStr('**********')), kwargs={'tools': [{'type': 'function', 'function': {'name': 'check_new_messages', 'description': 'Check messages.', 'parameters': {'properties': {}, 'type': 'object'}}}]}, config={}, config_factories=[]),\n ToolSet(tools={'check_new_messages': StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12c0dcea0&gt;)}))\n</code></pre> <p>Tools will be automatically used when we call any of the invoke or stream methods.</p> <p>Notice that the LLM behaves normally if the user's prompts are unrelated to the tool.</p> <pre><code>chatbot.invoke('Hello world!')\n</code></pre> <pre><code>ChatResult(content=Hello! How can I assist you today?, tool_calls=[])\n</code></pre> <p>If the LLM \"decides\" that the user needs to execute a tool, it returns a tool call as the response instead of returning content.</p> <pre><code>result = chatbot.invoke('Check my messages.')\nresult\n</code></pre> <pre><code>ChatResult(content=, tool_calls=[ToolCallInfo(id='call_ihfaGlFUvSl8OM0VQH4TkO9G', name='check_new_messages', type='tool_call', args={}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12c0dcea0&gt;))])\n</code></pre> <p>The tool call information can be accessed through the <code>ChatResult.tool_calls</code> attribute, which is simply a list supertype. Use <code>tool_info_str</code> to clearly show the arguments being passed to the function.</p> <pre><code>for tc in result.tool_calls:\n    print(tc.tool_info_str())\n</code></pre> <pre><code>check_new_messages()\n</code></pre> <p>You may also provide additional tools at the time of invoking the LLM, and it will be treated as if it was part of the chatbot. </p> <p>In this example, we create a new tool with two arguments that must be provided by the LLM.</p> <pre><code>@langchain_core.tools.tool\ndef send_message(recipient: str, text: str) -&gt; str:\n    '''Send messages to others.'''\n    return f'Message sent!'\n\nresult = chatbot.invoke('Send a message to Bob saying \"Hello!\"', tools=[send_message])\nresult\n</code></pre> <pre><code>ChatResult(content=, tool_calls=[ToolCallInfo(id='call_uXbyuViXTXHVO1zVohqydcW7', name='send_message', type='tool_call', args={'recipient': 'Bob', 'text': 'Hello!'}, tool=StructuredTool(name='send_message', description='Send messages to others.', args_schema=&lt;class 'langchain_core.utils.pydantic.send_message'&gt;, func=&lt;function send_message at 0x12c744720&gt;))])\n</code></pre> <p>You can see that the LLM provided the <code>recipient</code> and <code>text</code> arguments which were passed to the function call information.</p> <pre><code>result.tool_calls[0].tool_info_str()\n</code></pre> <pre><code>'send_message(recipient=Bob, text=Hello!)'\n</code></pre> <p>You can adjust behavior using the <code>tool_choice</code> argument in the chatbot constructor or at invokation. The value <code>'any'</code> means that a tool MUST be called, but all tools are candidates. The value <code>'auto'</code> (the default) allows the LLM to reply with normal content rather than a tool call, and you can also pass the name of a specific function as well.</p> <pre><code>result = chatbot.invoke('Go to the store for me!', tool_choice='any')\nresult.tool_calls[0].tool_info_str()\n</code></pre> <pre><code>'check_new_messages()'\n</code></pre>"},{"location":"examples/b-tool_calling/#executing-tools","title":"Executing Tools","text":"<p>Tools allow the LLM to determine if and when to execute tools and also provides parameters for the tool call based on conversation history, but the user containing function is responsible for actually executing the tool with the arguments from the LLM.</p> <p>Use the <code>execute_tools</code> method to actually execute the tool, which returns a mapping of tool names to <code>ToolCallResult</code> objects.</p> <pre><code>result = chatbot.invoke('Check my messages.')\nresult.tool_calls[0].tool_info_str()\n</code></pre> <pre><code>'check_new_messages()'\n</code></pre> <pre><code>tr = result.execute_tools()\ntr\n</code></pre> <pre><code>{'check_new_messages': ToolCallResult(info=ToolCallInfo(id='call_2KihzJGsgJ2Y0Qxy6r7920x6', name='check_new_messages', type='tool_call', args={}, tool=StructuredTool(name='check_new_messages', description='Check messages.', args_schema=&lt;class 'langchain_core.utils.pydantic.check_new_messages'&gt;, func=&lt;function check_new_messages at 0x12c0dcea0&gt;)), return_value='No new messages.')}\n</code></pre> <p>Get the return value from the tool through the <code>return_value</code> property.</p> <pre><code>tr['check_new_messages'].return_value\n</code></pre> <pre><code>'No new messages.'\n</code></pre> <p>Extracting tool calls from a <code>StreamResult</code> is a little more complicated because the stream must be exhausted before executing tools. This happens because the tool call information replaces the text response, so the streamer is essentially receiving chunks of the function call information until exhaustion.</p> <p>The calling function must handle both the streamed output and tool calls.</p> <pre><code>stream = chatbot.stream('Check my messages.')\nfor r in stream:\n    print(r, end='', flush=True)\nif len(stream.tool_calls) &gt; 0:\n    stream.execute_tools()\n</code></pre> <pre><code>content='' additional_kwargs={'tool_calls': [{'index': 0, 'id': 'call_Fq2o50ejL69YZjZugGxRrycv', 'function': {'arguments': '', 'name': 'check_new_messages'}, 'type': 'function'}]} response_metadata={} id='run-18230eaa-b7ab-4104-a231-eb30688ab393' tool_calls=[{'name': 'check_new_messages', 'args': {}, 'id': 'call_Fq2o50ejL69YZjZugGxRrycv', 'type': 'tool_call'}] tool_call_chunks=[{'name': 'check_new_messages', 'args': '', 'id': 'call_Fq2o50ejL69YZjZugGxRrycv', 'index': 0, 'type': 'tool_call_chunk'}]content='' additional_kwargs={'tool_calls': [{'index': 0, 'id': None, 'function': {'arguments': '{}', 'name': None}, 'type': None}]} response_metadata={} id='run-18230eaa-b7ab-4104-a231-eb30688ab393' tool_calls=[{'name': '', 'args': {}, 'id': None, 'type': 'tool_call'}] tool_call_chunks=[{'name': None, 'args': '{}', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]content='' additional_kwargs={} response_metadata={'finish_reason': 'tool_calls', 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_0aa8d3e20b'} id='run-18230eaa-b7ab-4104-a231-eb30688ab393'\n</code></pre> <p>A <code>ValueError</code> will be raised if the caller tries to execute tools before the stream is exhausted.</p> <pre><code>stream = chatbot.stream('Check my messages.')\nfor r in stream:\n    print(r.content, end='', flush=True)\n    break\ntry:\n    stream.execute_tools()\nexcept ValueError as e:\n    print('Exception was caught!')\n</code></pre> <pre><code>Exception was caught!\n</code></pre>"},{"location":"examples/b-tool_calling/#toolkits-and-tool-factories","title":"Toolkits and Tool Factories","text":"<p>Aside from providing a list of tools, you may also bind tools from toolkits and tool factories.</p> <ul> <li> <p><code>ToolKit</code>: class with a <code>get_tools() -&gt; list[BaseTool]</code> method. <code>ToolKit</code>s are part of the langchain interface, and the built-in tools often come as a subtype. Passed through the <code>toolkits: list[BaseToolkit]</code> argument.</p> </li> <li> <p>Tool Factories: functions that accept a chatbot as an argument and return tools. Useful when writing tools that interact with the original LLM because otherwise it would require partial initialization. Passed through the <code>tool_factories: ToolFactoryType</code> argument.</p> </li> </ul> <p>Note that these too may be provided at instantiation or at invokation.</p>"},{"location":"examples/b-tool_calling/#toolkit-example","title":"<code>ToolKit</code> Example","text":"<p>In this example, I enable the built-in Langchain <code>FileManagementToolkit</code> toolkit to allow the chatbot to list, read, and write files.</p> <pre><code>import tempfile\nfrom langchain_community.agent_toolkits import FileManagementToolkit\nwith tempfile.TemporaryDirectory() as wd:\n    file_tk = FileManagementToolkit(root_dir=str(wd))\n    result = chatbot.invoke('List the files in this directory.', toolkits=[file_tk])\n    print(result.tool_calls[0].tool_info_str())\n</code></pre> <pre><code>list_directory()\n</code></pre>"},{"location":"examples/b-tool_calling/#tool-factory-examples","title":"Tool Factory Examples","text":"<p>Now I create a tool factory that can be passed to the chatbot. This tool uses the chatbot reference to invoke the LLM with access to all of the same tools.</p> <pre><code>\ndef my_tool_factory(chatbot: simplechatbot.ChatBot) -&gt; list[langchain_core.tools.Tool]:\n    @langchain_core.tools.tool\n    def story_generator(topic: str) -&gt; str:\n        '''Generate a story absed on a particular topic.'''\n        result = chatbot.invoke(\n            f'Generate a story about {topic}. Your response should only include the text of the story and make it short but engaging.',\n        )\n        return result.content\n\n    return [story_generator]\n\nresult = chatbot.invoke('Generate a story about western cowboys.', tool_factories=[my_tool_factory])\ntc_result = result.execute_tools()\ntc_result['story_generator'].return_value\n</code></pre> <pre><code>'In the heart of the Wild West, where the sun kissed the rugged plains, a small town named Dusty Gulch thrived amidst the dust and the grit. The townsfolk revered their sheriff, a grizzled cowboy named Hank \"Six-Shooter\" McGraw, known for his quick draw and even quicker wit.\\n\\nOne fateful afternoon, a notorious outlaw gang, led by the infamous Red Jack, rode into town, stirring trouble and fear. With a band of rowdy gunslingers, they demanded the townspeople hand over their gold or face the consequences. The saloon doors swung open, and the townsfolk watched, hearts pounding, as Hank stepped out, his spurs jingling like a warning bell.\\n\\n\u201cNow hold on there, Red Jack,\u201d Hank called, his voice steady as the mountains. \u201cYou can\u2019t just waltz into Dusty Gulch and expect to take what ain\\'t yours.\u201d\\n\\nRed Jack smirked, his hand twitching above his holster. \u201cYou think you can stop us, McGraw? You\u2019re just one man against my crew.\u201d\\n\\nWith a confident grin, Hank replied, \u201cOne man with a little courage can make a mighty stand.\u201d The tension crackled like lightning in the summer air.\\n\\nAs the sun began to set, casting long shadows across the dirt street, a showdown loomed. Hank\u2019s hand hovered over his revolver, eyes locked on Red Jack. The town held its breath.\\n\\nIn a flash of movement, gunfire erupted, echoing through the canyon like thunder. Dust flew, and the air was thick with the smell of gunpowder. One by one, Hank outmaneuvered the outlaws, his sharpshooting a testament to years of practice. With a final, decisive shot, Red Jack crumpled to the ground.\\n\\nSilence fell over Dusty Gulch. The townspeople erupted in cheers as Hank stood tall, the hero of the day. They surrounded him, gratitude shining in their eyes, as he tipped his hat. In that moment, the spirit of the West thrived, a reminder that courage and honor could still prevail in a world of chaos.'\n</code></pre>"},{"location":"examples/b-tool_calling/#conclusions","title":"Conclusions","text":"<p>That is all! Now you know how to enable and disable tools that your LLM can use to do anything!</p>"},{"location":"examples/c-model_specific_chatbots/","title":"Model-specific ChatBots","text":"<p>While <code>ChatBot</code> instances can be created from any Langchain Chat interface, we created some convenient superclasses that have varying levels of model-specific behavior.</p> <p>Model-specific chatbots only differ from <code>ChatBot</code> in that they define static factory constructor methods, all named <code>new</code>. As each chat model needs to be installed separately, they must be accessed via separate imports.</p> <pre><code>import sys\nsys.path.append('..')\n\nimport simplechatbot\n</code></pre> <p>I will use the keychain to manage API keys for OpenAI and Mistral.</p> <pre><code>keychain = simplechatbot.devin.APIKeyChain.from_json_file('../keys.json')\n</code></pre> <p>Notice that we use a separate import statement to explicitly import the model-specific chatbots.</p> <pre><code>from simplechatbot.devin.ollama import OllamaChatBot\n\nchatbot = OllamaChatBot.new(\n    model_name = 'llama3.1', \n)\n</code></pre> <pre><code>from simplechatbot.devin.openai import OpenAIChatBot\n\nchatbot = OpenAIChatBot.new(\n    model_name = 'gpt-4o-mini', \n    api_key=keychain['openai'],\n)\n</code></pre> <pre><code>from simplechatbot.devin.mistral import MistralChatBot\n\nchatbot = MistralChatBot.new(\n    model_name = 'mistral-large-latest', \n    api_key=keychain['mistral'],\n)\n</code></pre>"},{"location":"examples/d_multi-agent_example/","title":"Multi-agent Examples","text":"<p>In this example I show an example of an agent that writes a story using a series of steps.</p> <ol> <li>The user provides an idea for their story.</li> <li>The <code>Outline Bot</code> generates an outline for the story including section titles and descriptions.</li> <li>The first section content is created by the <code>Story Bot</code> from section title/description and the overall story description.</li> <li>The <code>Summary Bot</code> creates a summary of the newly generated chapter.</li> <li>The section summary is passed to the <code>Story Bot</code> along with section title/description to generate the next section.</li> <li>All sections follow steps 3-5. ...</li> <li>The sections are combined into a full story.</li> </ol> <p></p> <pre><code>import sys\nsys.path.append('..')\n\nimport simplechatbot\nfrom simplechatbot.openai import OpenAIChatBot\n</code></pre> <pre><code>keychain = simplechatbot.APIKeyChain.from_json_file('../keys.json')\n\ndef new_chatbot(system_prompt: str):\n    return OpenAIChatBot.new(\n        model_name = 'gpt-4o-mini', \n        api_key=keychain['openai'],\n        system_prompt=system_prompt,\n    )\n\ndef stream_it(chatbot: simplechatbot.ChatBot) -&gt; simplechatbot.ChatResult:\n    stream = chatbot.chat_stream(None, add_to_history=False)\n    for chunk in stream:\n        print(chunk.content, end='', flush=True)\n    return stream.result()\n</code></pre> <pre><code>import pydantic\n\nfrom typing import Optional\n\n#from pydantic import BaseModel, Field\nimport pydantic\n\nclass StoryOutline(pydantic.BaseModel):\n    \"\"\"Outline of the story.\"\"\"\n\n    story_topic: str = pydantic.Field(description=\"The topic of the story.\")\n\n    part1_title: str = pydantic.Field(description=\"Title of Part 1 of the story.\")\n    part1_description: str = pydantic.Field(description=\"Longer description of part 1.\")\n\n    part2_title: str = pydantic.Field(description=\"Title of Part 2 of the story.\")\n    part2_description: str = pydantic.Field(description=\"Longer description of part 2.\")\n\n    part3_title: str = pydantic.Field(description=\"Title of Part 3 of the story.\")\n    part3_description: str = pydantic.Field(description=\"Longer description of part 3.\")\n\n\nsystem_prompt = '''\nThe user will provide you a description of a story, and you must create a chapter outline with titles and brief descriptions.\nEach section should contain a title and a brief description of what happens in that section.\nThe sections should all be part of a single narrative ark, but each section should have a complete beginning, middle, and end.\n'''\noutline_bot = new_chatbot(system_prompt)\n\nq = f'Write an outline for a story about two friends who met when they were young and then lost touch. They meet again as adults and have to navigate their new relationship.'\noutline: StoryOutline = outline_bot._model.with_structured_output(StoryOutline).invoke(q)\n#chatbot_joke = chatbot_base.clone(model_factory=lambda llm: llm.with_structured_output(Joke), clear_tools=True)\n#chatbot_joke.invoke('Tell me a joke about a chicken', max_tokens=50)\n\n#chatbot_joke.invoke('Tell me a joke about a chicken', max_tokens=50)\noutline\n</code></pre> <pre><code>StoryOutline(story_topic='Rekindling Old Friendships', part1_title='The Childhood Bond', part1_description='Two young boys, Alex and Ben, meet in their neighborhood and quickly become inseparable friends. They share adventures, secrets, and dreams, creating a strong bond that seems unbreakable. However, due to family circumstances, Ben moves away, and they lose touch. Their childhood memories linger, but life pulls them in different directions.', part2_title='Years Apart', part2_description='As the years pass, Alex and Ben grow up in different environments, shaping their identities and interests. Alex becomes a successful artist in his hometown, while Ben moves to a big city to pursue a career in technology. They both think of each other fondly but never make the effort to reconnect. Their lives seem fulfilling, but a sense of something missing remains.', part3_title='A Chance Encounter', part3_description=\"Fate intervenes when Alex visits the city for an art exhibition and unexpectedly runs into Ben. The initial surprise gives way to excitement as they reminisce about their childhood. However, both men struggle with their new adult lives, and the dynamic has changed. They navigate awkwardness, shared memories, and the challenge of rekindling their friendship while adapting to who they've become.\")\n</code></pre> <pre><code>def first_section_writer_prompt(story_topic: str, section_title: str, section_description: str):\n\n    return f'''\n    You are to write the first section of a larger story based on a general story topic, the name of the section, and a longer description of what happens.\n\n    Your responses should only include text that is part of the story.\n\n    General story topic: \"{story_topic}\"\n\n    Section title: \"{section_title}\"\n\n    Description: \"{section_description}\"\n\n    '''\ncb1 = new_chatbot(first_section_writer_prompt(outline.story_topic, outline.part1_title, outline.part1_description))\nch1_result = stream_it(cb1)\n</code></pre> <pre><code>**The Childhood Bond**\n\nThe sun hung low in the sky, casting golden rays across the quiet suburban street, where laughter and the sounds of summer filled the air. Alex sat on the curb, swinging his feet back and forth, watching the world around him with wide, curious eyes. It was a typical afternoon, the kind that promised adventure to any child willing to seek it. As he tossed a small pebble into the gutter, the sound of approaching footsteps caught his attention.\n\n\"Hey!\" a voice called out, bright and full of energy. Alex turned to see a boy his age, with wild brown hair and a grin that seemed to stretch from ear to ear. \"Wanna play?\"\n\n\"Sure!\" Alex replied, jumping up from his spot. \"What do you want to do?\"\n\n\"Let\u2019s go explore the woods!\" Ben suggested, pointing toward the dense line of trees at the end of the street. The woods had always been a place of mystery\u2014filled with whispered tales of hidden treasures and secret paths.\n\nThey bounded down the sidewalk, their laughter echoing in the warm air, as they ventured into the shaded realm of ancient trees. The scent of pine filled their lungs, and the sunlight filtered through the leaves, creating a mosaic of light and shadow on the forest floor.\n\n\"Race you to the big oak!\" Ben shouted, taking off without waiting for a response. Alex sprinted after him, their feet pounding against the soft earth, both boys giggling uncontrollably. Ben reached the tree first, his hands resting on the rough bark as he caught his breath.\n\n\"You're too slow!\" he teased, sticking out his tongue. Alex playfully shoved him, and they both collapsed into a heap of laughter on the grass, their carefree spirits unburdened by the weight of the world.\n\nAs the days turned into weeks, the two boys shared countless adventures. They built forts out of fallen branches, crafted imaginary worlds where they were heroes saving the day, and whispered secrets under the stars while lying on the cool grass. Their bond grew stronger with each passing moment, a friendship that felt as solid as the very ground they played upon.\n\nBut as summer waned and the leaves began to turn, change loomed on the horizon. One afternoon, Ben\u2019s mother called them inside, her voice tinged with a hint of sadness. \"Boys, we need to talk.\"\n\nAlex\u2019s heart sank as he looked at Ben, who had turned pale. The news came like a storm cloud rolling in, dark and unexpected: Ben's family was moving across the country for his dad\u2019s new job. The reality of it hit them both like a punch to the gut.\n\n\"But we can't!\" Alex protested, his voice trembling. \"We\u2019re best friends! You can\u2019t just leave!\"\n\n\"I don\u2019t want to go, either,\" Ben replied, tears welling in his eyes. \"But we have to.\"\n\nIn the days that followed, they clung to every moment, making promises that felt both essential and fragile. They carved their initials into the trunk of the big oak, a testament to their friendship. They shared one last adventure\u2014their secret hideout where they had buried a time capsule filled with treasures, a token of their childhood dreams.\n\nWhen the day finally came for Ben to leave, Alex felt as if a part of him was being torn away. They stood on the front porch, the weight of unspoken words heavy between them. Ben hugged Alex tightly, whispering, \"No matter what, you\u2019ll always be my best friend.\"\n\nAs the car pulled away, Alex watched Ben\u2019s face grow smaller and smaller until it vanished from sight. The laughter that once filled their days faded into silence, replaced by the bittersweet memories of their shared childhood.\n\nTime passed, and life pulled them in different directions. Alex would often find himself wandering back to that old oak, tracing the letters they carved into its bark, feeling the warmth of their friendship linger like the fading summer sun. Though the world had changed, the bond they formed remained etched in his heart, a cherished piece of his childhood that he would never forget.\n</code></pre> <pre><code>def summary_prompt(story_so_far: str) -&gt; str:\n    return f'''\n    You need to create a summary of the following section of a story that can be used as a starting point for writing the next section.\n\n    Your responses should only include text that is part of the story.\n\n    The previous section of the story:\n\n    {story_so_far}\n    '''\ncb1_sum = new_chatbot(summary_prompt(ch1_result.content))\nch1_sum = stream_it(cb1_sum)\n</code></pre> <pre><code>**Summary: The Childhood Bond**\n\nOn a sunny afternoon, Alex meets Ben, a boy with wild hair, and they embark on a series of adventures in the nearby woods, building a strong friendship filled with laughter and imaginative play. As summer ends, they face the heartbreaking news that Ben's family is moving away, leading to emotional goodbyes and promises to remain best friends. They create lasting memories, including carving their initials into a tree and burying a time capsule. After Ben leaves, Alex struggles with the absence of his friend but holds onto the cherished memories of their childhood bond, visiting their secret spot and reflecting on what they shared.\n</code></pre> <pre><code>def next_section_writer_prompt(story_topic: str, section_title: str, section_description: str, story_so_far: str):\n    return f'''\n    You are to write the first section of a larger story based on a general story topic, the name of the section, and a longer description of what happens.\n\n    Your responses should only include text that is part of the story.\n\n    General story topic: \"{story_topic}\"\n\n    Summary of previous section: \"{story_so_far}\"\n\n    Section title: \"{section_title}\"\n\n    Description: \"{section_description}\"\n\n    '''\ncb2 = new_chatbot(next_section_writer_prompt(outline.story_topic, outline.part2_title, outline.part2_description, ch1_sum.content))\nch2_result = stream_it(cb2)\n</code></pre> <pre><code>**Years Apart**\n\nAs the sun dipped below the horizon, painting the sky in hues of orange and purple, Alex stood in his small studio, surrounded by canvases that captured the beauty of his hometown. He dipped his brush into a palette of colors, each stroke a reflection of the life he had built since Ben moved away. The quaint streets, the familiar faces, and the gentle rustling of leaves in the nearby woods were his muses, but amidst the vibrant scenes he created, there lingered an emptiness. He often found himself staring at the tree they had carved their initials into, a bittersweet reminder of a friendship that had weathered the storms of childhood but faded with time.\n\nMeanwhile, in the bustling heart of the city, Ben was immersed in the world of technology, surrounded by the hum of computers and the glow of screens. He had traded the rustling leaves for the cacophony of urban life, and although he thrived in his career, he often found himself reminiscing about the adventures he and Alex had shared. Late-night coding sessions were accompanied by thoughts of the laughter they had exchanged over makeshift campfires, and the thrill of their secret hideouts in the woods. Yet, in the whirlwind of deadlines and city life, Ben never found the courage to reach out. The years slipped by, each month a reminder of the bond that once was, now an echo of the past.\n\nBoth men moved through their lives with a sense of fulfillment, yet an unshakeable feeling lingered\u2014something was missing. Alex found success in galleries and art shows, but often, when he received compliments, he would imagine how Ben would have reacted, his wild hair bouncing with excitement. Ben, in turn, celebrated promotions and accolades, but every achievement felt slightly hollow without someone to share it with, someone who understood his journey from the very beginning.\n\nDespite the distance, both men held a piece of each other in their hearts. They would occasionally scroll through old photos on their phones\u2014pictures of them grinning widely, arms slung around each other, with the woods stretching behind them like a canvas of childhood. Those images brought warmth, yet they also served as a reminder of what had been lost to time and circumstance.\n\nAs the seasons changed, Alex found himself at a crossroads. He had completed his latest collection and was preparing for an exhibition that would showcase the essence of growth and change. But as he framed the last piece, a painting inspired by the memories of his childhood with Ben, he felt a tug at his heart\u2014a longing to reconnect, to bridge the years that had kept them apart.\n\nOn the other side of the city, Ben sat in his apartment, staring at a screen filled with code that seemed to blur together. In a moment of nostalgia, he opened a drawer and pulled out an old, worn-out notebook\u2014the very one they had used to jot down their dreams and plans as kids. As he flipped through its pages, memories flooded back, reminding him of the simplicity of their friendship and the joy it had brought him. He felt a stirring in his chest, a desire to reach out, to rekindle what they had lost.\n\nBoth men were on the brink of change, standing before the door that separated them from a reunion, unaware that fate had a plan to unite them once more.\n</code></pre> <pre><code>cb2_sum = new_chatbot(summary_prompt(ch2_result.content))\nch2_sum = stream_it(cb2_sum)\n</code></pre> <pre><code>As Alex prepares for his exhibition, he feels a strong desire to reconnect with Ben, the memories of their childhood friendship weighing heavily on his heart. Meanwhile, Ben reflects on their shared past while going through an old notebook filled with dreams they once had, igniting a yearning to reach out to Alex. Both men stand at a pivotal moment in their lives, ready to bridge the gap that years of distance have created, unaware that fate is orchestrating their reunion.\n</code></pre> <pre><code>cb3 = new_chatbot(next_section_writer_prompt(outline.story_topic, outline.part2_title, outline.part2_description, ch1_sum.content))\nch3_result = stream_it(cb3)\n</code></pre> <pre><code>**Years Apart**\n\nThe years drifted by like leaves caught in a gentle autumn breeze, swirling through the seasons of life. Alex found solace in the vibrant colors of his paintbrush, each stroke on the canvas a tribute to the adventures he once shared with Ben. The small town felt comforting, its familiar streets and friendly faces wrapping around him like a warm blanket. Yet, in the quiet moments, when the sun dipped below the horizon and shadows danced across his studio, a flicker of nostalgia would ignite in his heart, reminding him of laughter echoing through the woods and the promise of forever friendship whispered beneath the tall oak tree.\n\nMeanwhile, in the bustling heart of the city, Ben navigated the concrete labyrinth of his new life, his wild hair now tamed into a professional style that suited his ambitions in technology. He thrived amidst the buzz of innovation and the thrill of new challenges. Yet, even as he climbed the corporate ladder, the faint memory of a childhood friend lingered at the edges of his consciousness. On weekends, when he would visit parks or cafes bustling with laughter, he often found himself gazing at the sky, imagining if Alex was somewhere painting the very clouds that drifted above.\n\nBoth boys, now men, had buried their friendship beneath the weight of their new realities. Alex attended art shows and mingled with fellow creatives, sharing stories and dreams with kindred spirits. He often caught himself mentioning a friend from his childhood, a wistful smile breaking across his face, but the conversations would inevitably shift, and Ben's name would fade into the background, a ghost of a memory.\n\nIn the city, Ben would occasionally scroll through his phone, pausing at old photos from a summer long gone. His heart would swell with the joy of those carefree days, yet the urge to reconnect faded like the last light of day. He had built a life filled with achievement and ambition, but the emptiness of missing a true friend nagged at him, a silent ache he couldn\u2019t quite place.\n\nYears passed, and both Alex and Ben found themselves in comfortable routines, their lives rich with experiences but lacking the depth of shared memories. It wasn\u2019t until one fateful autumn day, when Alex received an unexpected email, that the past came rushing back. The subject line read: \u201cA Blast from the Past,\u201d and when he opened it, he was met with a familiar face, a digital snapshot of Ben standing in front of a tech conference banner, his trademark grin lighting up the screen.\n\nWith trembling fingers, Alex typed a response, his heart racing at the thought of rekindling a friendship that had once meant the world to him. \u201cHey, Ben! It\u2019s been too long. How have you been?\u201d\n\nAs he hit send, he felt a spark of hope, the kind that flickers in the darkest of times, and for the first time in years, the thread of their childhood bond began to weave its way back into their lives.\n</code></pre> <pre><code>cb3_sum = new_chatbot(summary_prompt(ch3_result.content))\nch3_sum = stream_it(cb3_sum)\n</code></pre> <pre><code>As Alex waited for a reply, memories of their shared past flooded his mind. He recalled the laughter, the adventures, and the promises made under the oak tree. Each moment felt like a thread pulling him back to a time when their friendship was unbreakable. Meanwhile, Ben sat in his modern apartment, staring at the email notification that had just pinged on his screen. A rush of emotions surged through him as he recognized Alex\u2019s name. He hesitated for a moment, grappling with the weight of the years that had passed and the life he had built without his childhood friend.\n\nFinally, with a deep breath, he opened the email. The warmth of Alex's words brought a smile to his face, and he felt a longing to reconnect. As he began to type his response, he considered how much he missed the simplicity of their friendship and the joy that came from just being together. The excitement of rediscovering their bond filled him with a sense of purpose.\n\nBoth men stood on the precipice of change, their hearts igniting with the possibility of rekindling a friendship that had lingered in the shadows for too long. Little did they know, this was just the beginning of a journey that would lead them back to each other, challenging them to confront the years apart and the lives they had built in solitude.\n</code></pre> <pre><code>story = dict()\nstory[outline.part1_title] = ch1_result.content\nstory[outline.part2_title] = ch2_result.content\nstory[outline.part3_title] = ch3_result.content\nstory.keys()\n</code></pre> <pre><code>dict_keys(['The Childhood Bond', 'Years Apart', 'A Chance Encounter'])\n</code></pre> <pre><code>for title, content in story.items():\n    print(f'\\n\\n\\n{title}\\n\\n{content}\\n\\n\\n')\n</code></pre> <pre><code>The Childhood Bond\n\n**The Childhood Bond**\n\nThe sun hung low in the sky, casting golden rays across the quiet suburban street, where laughter and the sounds of summer filled the air. Alex sat on the curb, swinging his feet back and forth, watching the world around him with wide, curious eyes. It was a typical afternoon, the kind that promised adventure to any child willing to seek it. As he tossed a small pebble into the gutter, the sound of approaching footsteps caught his attention.\n\n\"Hey!\" a voice called out, bright and full of energy. Alex turned to see a boy his age, with wild brown hair and a grin that seemed to stretch from ear to ear. \"Wanna play?\"\n\n\"Sure!\" Alex replied, jumping up from his spot. \"What do you want to do?\"\n\n\"Let\u2019s go explore the woods!\" Ben suggested, pointing toward the dense line of trees at the end of the street. The woods had always been a place of mystery\u2014filled with whispered tales of hidden treasures and secret paths.\n\nThey bounded down the sidewalk, their laughter echoing in the warm air, as they ventured into the shaded realm of ancient trees. The scent of pine filled their lungs, and the sunlight filtered through the leaves, creating a mosaic of light and shadow on the forest floor.\n\n\"Race you to the big oak!\" Ben shouted, taking off without waiting for a response. Alex sprinted after him, their feet pounding against the soft earth, both boys giggling uncontrollably. Ben reached the tree first, his hands resting on the rough bark as he caught his breath.\n\n\"You're too slow!\" he teased, sticking out his tongue. Alex playfully shoved him, and they both collapsed into a heap of laughter on the grass, their carefree spirits unburdened by the weight of the world.\n\nAs the days turned into weeks, the two boys shared countless adventures. They built forts out of fallen branches, crafted imaginary worlds where they were heroes saving the day, and whispered secrets under the stars while lying on the cool grass. Their bond grew stronger with each passing moment, a friendship that felt as solid as the very ground they played upon.\n\nBut as summer waned and the leaves began to turn, change loomed on the horizon. One afternoon, Ben\u2019s mother called them inside, her voice tinged with a hint of sadness. \"Boys, we need to talk.\"\n\nAlex\u2019s heart sank as he looked at Ben, who had turned pale. The news came like a storm cloud rolling in, dark and unexpected: Ben's family was moving across the country for his dad\u2019s new job. The reality of it hit them both like a punch to the gut.\n\n\"But we can't!\" Alex protested, his voice trembling. \"We\u2019re best friends! You can\u2019t just leave!\"\n\n\"I don\u2019t want to go, either,\" Ben replied, tears welling in his eyes. \"But we have to.\"\n\nIn the days that followed, they clung to every moment, making promises that felt both essential and fragile. They carved their initials into the trunk of the big oak, a testament to their friendship. They shared one last adventure\u2014their secret hideout where they had buried a time capsule filled with treasures, a token of their childhood dreams.\n\nWhen the day finally came for Ben to leave, Alex felt as if a part of him was being torn away. They stood on the front porch, the weight of unspoken words heavy between them. Ben hugged Alex tightly, whispering, \"No matter what, you\u2019ll always be my best friend.\"\n\nAs the car pulled away, Alex watched Ben\u2019s face grow smaller and smaller until it vanished from sight. The laughter that once filled their days faded into silence, replaced by the bittersweet memories of their shared childhood.\n\nTime passed, and life pulled them in different directions. Alex would often find himself wandering back to that old oak, tracing the letters they carved into its bark, feeling the warmth of their friendship linger like the fading summer sun. Though the world had changed, the bond they formed remained etched in his heart, a cherished piece of his childhood that he would never forget.\n\n\n\n\n\n\nYears Apart\n\n**Years Apart**\n\nAs the sun dipped below the horizon, painting the sky in hues of orange and purple, Alex stood in his small studio, surrounded by canvases that captured the beauty of his hometown. He dipped his brush into a palette of colors, each stroke a reflection of the life he had built since Ben moved away. The quaint streets, the familiar faces, and the gentle rustling of leaves in the nearby woods were his muses, but amidst the vibrant scenes he created, there lingered an emptiness. He often found himself staring at the tree they had carved their initials into, a bittersweet reminder of a friendship that had weathered the storms of childhood but faded with time.\n\nMeanwhile, in the bustling heart of the city, Ben was immersed in the world of technology, surrounded by the hum of computers and the glow of screens. He had traded the rustling leaves for the cacophony of urban life, and although he thrived in his career, he often found himself reminiscing about the adventures he and Alex had shared. Late-night coding sessions were accompanied by thoughts of the laughter they had exchanged over makeshift campfires, and the thrill of their secret hideouts in the woods. Yet, in the whirlwind of deadlines and city life, Ben never found the courage to reach out. The years slipped by, each month a reminder of the bond that once was, now an echo of the past.\n\nBoth men moved through their lives with a sense of fulfillment, yet an unshakeable feeling lingered\u2014something was missing. Alex found success in galleries and art shows, but often, when he received compliments, he would imagine how Ben would have reacted, his wild hair bouncing with excitement. Ben, in turn, celebrated promotions and accolades, but every achievement felt slightly hollow without someone to share it with, someone who understood his journey from the very beginning.\n\nDespite the distance, both men held a piece of each other in their hearts. They would occasionally scroll through old photos on their phones\u2014pictures of them grinning widely, arms slung around each other, with the woods stretching behind them like a canvas of childhood. Those images brought warmth, yet they also served as a reminder of what had been lost to time and circumstance.\n\nAs the seasons changed, Alex found himself at a crossroads. He had completed his latest collection and was preparing for an exhibition that would showcase the essence of growth and change. But as he framed the last piece, a painting inspired by the memories of his childhood with Ben, he felt a tug at his heart\u2014a longing to reconnect, to bridge the years that had kept them apart.\n\nOn the other side of the city, Ben sat in his apartment, staring at a screen filled with code that seemed to blur together. In a moment of nostalgia, he opened a drawer and pulled out an old, worn-out notebook\u2014the very one they had used to jot down their dreams and plans as kids. As he flipped through its pages, memories flooded back, reminding him of the simplicity of their friendship and the joy it had brought him. He felt a stirring in his chest, a desire to reach out, to rekindle what they had lost.\n\nBoth men were on the brink of change, standing before the door that separated them from a reunion, unaware that fate had a plan to unite them once more.\n\n\n\n\n\n\nA Chance Encounter\n\n**Years Apart**\n\nThe years drifted by like leaves caught in a gentle autumn breeze, swirling through the seasons of life. Alex found solace in the vibrant colors of his paintbrush, each stroke on the canvas a tribute to the adventures he once shared with Ben. The small town felt comforting, its familiar streets and friendly faces wrapping around him like a warm blanket. Yet, in the quiet moments, when the sun dipped below the horizon and shadows danced across his studio, a flicker of nostalgia would ignite in his heart, reminding him of laughter echoing through the woods and the promise of forever friendship whispered beneath the tall oak tree.\n\nMeanwhile, in the bustling heart of the city, Ben navigated the concrete labyrinth of his new life, his wild hair now tamed into a professional style that suited his ambitions in technology. He thrived amidst the buzz of innovation and the thrill of new challenges. Yet, even as he climbed the corporate ladder, the faint memory of a childhood friend lingered at the edges of his consciousness. On weekends, when he would visit parks or cafes bustling with laughter, he often found himself gazing at the sky, imagining if Alex was somewhere painting the very clouds that drifted above.\n\nBoth boys, now men, had buried their friendship beneath the weight of their new realities. Alex attended art shows and mingled with fellow creatives, sharing stories and dreams with kindred spirits. He often caught himself mentioning a friend from his childhood, a wistful smile breaking across his face, but the conversations would inevitably shift, and Ben's name would fade into the background, a ghost of a memory.\n\nIn the city, Ben would occasionally scroll through his phone, pausing at old photos from a summer long gone. His heart would swell with the joy of those carefree days, yet the urge to reconnect faded like the last light of day. He had built a life filled with achievement and ambition, but the emptiness of missing a true friend nagged at him, a silent ache he couldn\u2019t quite place.\n\nYears passed, and both Alex and Ben found themselves in comfortable routines, their lives rich with experiences but lacking the depth of shared memories. It wasn\u2019t until one fateful autumn day, when Alex received an unexpected email, that the past came rushing back. The subject line read: \u201cA Blast from the Past,\u201d and when he opened it, he was met with a familiar face, a digital snapshot of Ben standing in front of a tech conference banner, his trademark grin lighting up the screen.\n\nWith trembling fingers, Alex typed a response, his heart racing at the thought of rekindling a friendship that had once meant the world to him. \u201cHey, Ben! It\u2019s been too long. How have you been?\u201d\n\nAs he hit send, he felt a spark of hope, the kind that flickers in the darkest of times, and for the first time in years, the thread of their childhood bond began to weave its way back into their lives.\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"}]}